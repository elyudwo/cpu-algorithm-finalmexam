## 컴퓨터 알고리즘 기말고사 simulated annealing algorithm

## 1.사전지식

회귀식을 가정한뒤 에러를 최소화한 모수 값을 최적화 알고리즘을 이용해 추정하는 것이 과제이기 때문에 시작에 앞서 회귀분석에 대해서 알아야했습니다.

회귀분석이란 독립변수(x)로 종속변수(y)를 예측하는 것을 의미합니다. 

위의 사실만 인지하였다면 담금질 알고리즘을 이용해 회귀식의 에러를 최소화하는 모수 값을 구할수있습니다.

## 2-1).알고리즘설명

교수님께서 수업때 설명하셨듯이 넓게 보았을때 담금질 알고리즘은 현재 상태와 인접한 상태를 하나 구한뒤, 그 상태로 변할 때 얼마만큼 이득인지, 혹은 손해인지 판단한 뒤 얻을 이득과 손해의 정도에 따라 확률적으로 그 상태로 이동하는 알고리즘입니다.

인접 상태를 구할 때 해를 반복해 개선함으로써, 현재의 해 근방에 있는 해를 임의로 찾는데, 그때에 주어진 함수의 값과 <온도> 가 영향을 줍니다.

온도를 설정한 이유는 교수님께서 설명하신대로 등산할 때 내가 오른 언덕이 최고점이라 생각한곳이었지만 더 높은 언덕이 있을때를 대비해서 설정된 것입니다. 

처음에는 온도 값이 크지만 해를 반복해갈수록 <온도값이 줄어들어서> 해의 변화정도가 줄어들게되며 최적해에 가까워집니다. 이러한 이유는 가장 높은 언덕을 찾은 이후에는 세밀한 탐색을 통해 최적해에 최대한 가까이 가기위함 입니다.

## 2-2) 알고리즘 순서도

평가 함수 정의 --> 이동 --> 온도 감소

위와같은 순서를 따르는 담금질 알고리즘에서 평가 함수 정의에 대해 먼저 살펴보겠습니다
일단 에러를 최소화한 모수 값을 향해 가려고 한다면 이 해가 얼마나 최적해에 가까운지를 알려줄 수 있는 방법이 필요합니다. 그래서 이를 평가 함수라고 부르고 알고리즘 시작 전 정의해줘야 합니다.

```
double f(double x) 
{
    return x = pow(x, 2) + 2 * pow(x,1) + 1; 
}
```
평가 함수를 만들어주기 위해 위와같은 코드를 사용했습니다.

그후 담금질 알고리즘의 포인트인 이동을 해야합니다.

특정확률에 따라 이동이 결정되는 담금질 알고리즘의 경우 e^((e1-e2)/kt) 와 같은 공식을 따릅니다. 

여기서 e1은 현재 에너지, e2는 나중 에너지 k는 볼츠만상수(상수값이기 때문에 알고리즘 내에서는 사용하지않음) t는 현재 온도입니다. 

여기서 "에너지" 라는 말을 사용했는데 에너지는 평가 함수의 값을 의미합니다. 

그 후 2-1)에서 설명했듯 이동을 반복할수록 최적해에 가까워져야합니다. 이 때 최적해에 가까워지기 위해서는 온도값이 줄어들면서 세밀한 탐색을 해야합니다. 

그래서 온도값을 줄이기 위해 cooling 변수를 선언해준뒤 반복문을 진행합니다.

코드는 아래와 같습니다.
```
    time_t systime;                               
    time(&systime);
    srand((unsigned int)systime);
    double cooling = 0.9;            // 진행에 따라 온도값을 줄여주는 cooling 변수
    const double e = 2.718281828;	// 확률 계산을 위한 변수 e
    
    
    int cnt = 0;	// 이동 횟수
    int cnt1 = 0;	// 반복문 반복 횟수
    double lee[10000];	// 알고리즘 진행과정 추적을 위한 배열
    
    double x = 3; // 초기값
 
    cout << "처음 상태 = " << x << "\t, 값 F(x)= " << f(x) << endl;	
  ```
##### 진행에 따라 온도값을 줄여주는 cooling 변수를 0.9로 선언했습니다
##### 이동횟수와 반복문 반복 횟수를 찾기위해 cnt와 cnt1을 선언했습니다.
##### 이동 할때마다의 해를 추적하는 lee 배열을 선언했습니다.
##### 초기값을 3 으로 설정한 이유는 찾고자 하는 최적해로부터 멀어진 값을 초기값으로 설정한뒤 점점 최적해로 다가가는 과정을 설명하기 위함입니다.

아래 그림은 초기 설정한 함수  y = x^2+2^x+1 의 그래프입니다.

![image](https://user-images.githubusercontent.com/97587573/173231940-dde2c522-9702-44bf-9a65-a8a3ffa615ca.png)

아래 코드는 그래프의 최적값인 -1로 다가가기위한 반복문 코드입니다

```
    double L = f(x);
 
    for (double T = 80; T > 0.000008; T *= cooling) 
    {
      	cnt1++;
        double xNew = x + ((rand() / (double)RAND_MAX) * 2 - 1);
        double LNew = f(xNew);
        if (LNew < L || (rand() / (double)RAND_MAX) <= pow(e, -(LNew - L) / T))
        {
            L = LNew;
            x = xNew;
            lee[cnt++] = f(x);
        }
    }
```

반복문 진행과정을 순서대로 설명해보겠습니다.

1. L 변수에 초기값 저장

2. 온도변수를 기준으로 반복문 실행
 
3. xNew 변수에 현재 초기 x값을 기준으로 -1 ~ 1 만큼의 거리를 이동한 값(독립변수)을 저장해준다.

4. LNew 변수에 f(xNew) 의 값을 대입해(종속변수) 저장해준다. (편의를 위해 L값은 에너지로 설명) 

5. 구하고자 하는 값이 함수에서의 최솟값이므로 현재 에너지(L) 값이 나중 에너지(LNew) 값보다 크면 if문 실행

6. 현재 에너지 값을 나중 에너지로 바꿔주고 현재의 독립변수값을 나중 독립변수로 바꿔준다.

7. 에너지 변화 값 추정을 위해 lee배열에 현재 에너지를 저장해줍니다.

8. 현재의 온도값에 cooling 값을 곱해주어 온도를 감소시킵니다.

##### if 문 안의 아래 조건식은 후에 부연설명 하겠습니다.
```
(rand() / (double)RAND_MAX) <= pow(e, -(LNew - L) / T)
```

그 뒤 아래 코드를 통해 값을 출력합니다 
```
    cout << "최종 상태 = " << x << "\t, 값 F(x) = " << f(x) << endl << endl;
    
    for(int i=0; i<cnt-1; i++) {
    	cout << lee[i] << " ";
	}
```
![image](https://user-images.githubusercontent.com/97587573/173234568-f09ab4c1-9cd7-4c03-b8dd-809228f52f6c.png)

모수값인 0 으로 적절하게 다가가는것을 볼수있습니다. 

![image](https://user-images.githubusercontent.com/97587573/173234587-595529db-a537-44d4-894f-ce71fa1d2910.png)

에너지의 변화과정 또한 위와같이 모수값을 향해 가는것을 볼수있습니다.

## 2-3) 알고리즘 심화 탐구

아래 코드에 대해 설명하겠습니다.
```
(rand() / (double)RAND_MAX) <= pow(e, -(LNew - L) / T)
```

이전에 설정했던 평가함수는 2차함수였기 때문에 그래프의 최대 혹은 최솟값은 항상 하나입니다.
```
LNew < L || (rand() / (double)RAND_MAX)
```
그렇기에 위의 코드만으로도 모수값을 구할수 있었습니다.

하지만 x^4-3x^3+2x+3 인 아래 그림과 같은 함수에서는 최솟값이 두개가 생기기 때문에 초기 독립변수값을 -1 로 설정할시 최적해를 구할수 없습니다.
![image](https://user-images.githubusercontent.com/97587573/173235070-3ecf82a3-894b-4867-b432-6ba6fe7a50b6.png)

```
(rand() / (double)RAND_MAX) <= pow(e, -(LNew - L) / T)
```
위의 코드는 그런 상황일 경우 현재 에너지보다 나중 에너지의 값이 더 클경우에도 현재 에너지값을 나중 에너지로 바꿔주는 식입니다.

반복문을 거듭할수록 T의 값이 줄어들며 pow(e, -(LNew - L) / T) 값이 작아집니다. 이에 따라 위의 식이 성립될 확률이 줄어드는데 이는 최적해가 가까워질수록 세밀한 탐색을 통해 최적해에 다가가기 위함 입니다.

## 2-4) 부연설명

만약 구하고 싶은 모수값이 최솟값이 아니고 최대값일 경우가 있습니다.

이럴때는 
```
if (LNew > L || (rand() / (double)RAND_MAX) <= pow(e, -(L - LNew) / T))
```
if문 안의 나중 에너지가 현재 에너지의 값보다 클때 또는 확률을 LNew-L이 아닌 L-Lnew로 바꿔주면 최대값을 구할 수 있습니다.
