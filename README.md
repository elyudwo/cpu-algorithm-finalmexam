## 컴퓨터 알고리즘 기말고사 simulated annealing algorithm

## 1.사전지식

회귀식을 가정한뒤 에러를 최소화한 모수 값을 최적화 알고리즘을 이용해 추정하는 것이 과제이기 때문에 시작에 앞서 회귀분석에 대해서 알아야했습니다.

회귀분석이란 독립변수(x)로 종속변수(y)를 예측하는 것을 의미합니다. 

위의 사실만 인지하였다면 담금질 알고리즘을 이용해 회귀식의 에러를 최소화하는 모수 값을 구할수있습니다.

## 2-1).알고리즘설명

교수님께서 수업때 설명하셨듯이 넓게 보았을때 담금질 알고리즘은 현재 상태와 인접한 상태를 하나 구한뒤, 그 상태로 변할 때 얼마만큼 이득인지, 혹은 손해인지 판단한 뒤 얻을 이득과 손해의 정도에 따라 확률적으로 그 상태로 이동하는 알고리즘입니다.

인접 상태를 구할 때 해를 반복해 개선함으로써, 현재의 해 근방에 있는 해를 임의로 찾는데, 그때에 주어진 함수의 값과 <온도> 가 영향을 줍니다.

온도를 설정한 이유는 교수님께서 설명하신대로 등산할 때 내가 오른 언덕이 최고점이라 생각한곳이었지만 더 높은 언덕이 있을때를 대비해서 설정된 것입니다. 

처음에는 온도 값이 크지만 해를 반복해갈수록 <온도값이 줄어들어서> 해의 변화정도가 줄어들게되며 최적해에 가까워집니다. 이러한 이유는 가장 높은 언덕을 찾은 이후에는 세밀한 탐색을 통해 최적해에 최대한 가까이 가기위함 입니다.

## 2-2) 알고리즘 순서도

평가 함수 정의 --> 이동 --> 온도 감소

위와같은 순서를 따르는 담금질 알고리즘에서 평가 함수 정의에 대해 먼저 살펴보겠습니다
일단 에러를 최소화한 모수 값을 향해 가려고 한다면 이 해가 얼마나 최적해에 가까운지를 알려줄 수 있는 방법이 필요합니다. 그래서 이를 평가 함수라고 부르고 알고리즘 시작 전 정의해줘야 합니다.

```
double f(double x) 
{
    return x = pow(x, 2) + 2 * pow(x,1) + 1; 
}
```
평가 함수를 만들어주기 위해 위와같은 코드를 사용했습니다.

그후 담금질 알고리즘의 포인트인 이동을 해야합니다.

담금질 알고리즘의 특정확률에 따라 이동이 결정되는 담금질 알고리즘의 경우 e^((e1-e2)/kt) 의 공식을 따릅니다. 

여기서 e1은 현재 에너지, e2는 나중 에너지 k는 볼츠만상수(상수값이기 때문에 알고리즘 내에서는 사용하지않음) t는 현재 온도입니다. 

여기서 "에너지" 라는 말을 사용했는데 에너지는 평가 함수의 값을 의미합니다. 

2-1)에서 설명했듯 이동을 반복할수록 최적해에 가까워져야합니다. 이 때 최적해에 가까워지기 위해서는 온도값이 줄어들면서 세밀한 탐색을 해야합니다. 

그래서 온도값을 줄이기 위해 cooling 변수를 선언해준뒤 반복문을 진행합니다.

코드는 아래와 같습니다.
```
    time_t systime;                               
    time(&systime);
    srand((unsigned int)systime);
    double cooling = 0.9;            
    const double e = 2.718281828;
    
    
    int cnt = 0;
    int cnt1 = 0;
    double lee[10000];
    
    double x = 1; 
 
    cout << "처음 상태 = " << x << "\t, 값 F(x)= " << f(x) << endl;
 
    double L = f(x);
 
    for (double T = 80; T > 0.000008; T *= cooling) 
    {
       cnt1++;
        double xNew = x + ((rand() / (double)RAND_MAX) * 2 - 1);
        double LNew = f(xNew);
        if (LNew < L || (rand() / (double)RAND_MAX) <= pow(e, -(LNew - L) / T))
        {
            L = LNew;
            x = xNew;
            lee[cnt++] = f(x);
        }
    }
    

    
    cout << "최종 상태 = " << x << "\t, 값 F(x) = " << f(x) << endl << endl;
    cout << cnt << " " << cnt1 << endl;
    
    for(int i=0; i<cnt-1; i++) {
    	cout << lee[i] << " ";
	}
  ```
